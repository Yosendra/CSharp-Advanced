class Shared
{
    public static int[] Data { get; set; }      // Store data values generated by producer thread
    public static int BatchCount { get; set; }          // Renamed: Total numbers of batches
    public static int BatchSize { get; set; }

    // Object of ManualResetEvent for signaling thread.
    // Placed here so it can be accessed by both Producer and Consumer Thread
    public static ManualResetEvent Event { get; set; }

    static Shared()
    {
        Data = new int[15];
        BatchCount = 5;
        BatchSize = 3;
        Event = new ManualResetEvent(false);    // We want it unsignaled by default at start up, so give it false
    }
}

// Represents the producer thread
class Producer
{
    public void Produce()
    {
        Console.WriteLine($"{Thread.CurrentThread.Name} started");

        for (int i = 0; i < Shared.BatchCount; i++)     // 5 times
        {
            // Generate some data and store it to data array
            for (int j = 0; j < Shared.BatchSize; j++)      // 3 times
            {
                Shared.Data[i * Shared.BatchSize + j] = (i * Shared.BatchSize) + j + 1;     // 1 to 15

                // Simulate latency
                Thread.Sleep(300);
            }

            // Set the signal (signal that the producer has finished generating data)
            Shared.Event.Set();

            // Reset the signal (makes the consumer thread wait for signal before reading next batch)
            // In ManualResetEvent, we deliberately put this after invoke .Set() so when another thread invoke .WaitOne() that thread will be blocked
            // waiting for a signal given by another thread through .Set() method to continue its execution.
            Shared.Event.Reset();
        }

        Console.WriteLine($"{Thread.CurrentThread.Name} completed");
    }
}

// Represents the consumer thread
class Consumer
{
    public void Consume()
    {
        Console.WriteLine($"{Thread.CurrentThread.Name} started");
        Console.WriteLine("Consumer thread is waiting for producer thread to finish generating data");

        for (int i = 0; i < Shared.BatchCount; i++)
        {
            // Consumer thread waits until the status of event becomes signaled
            Shared.Event.WaitOne();

            // Producer data has signaled finish, so the consumer thread will continue execute the code below
            Console.WriteLine("Consumer thread has received a signal from the producer thread");

            Console.WriteLine("The data : ");
            for (int j = 0; j < Shared.BatchSize; j++)
            {
                Console.WriteLine(Shared.Data[i * Shared.BatchSize + j]);
            }
        }

        Console.WriteLine($"{Thread.CurrentThread.Name} completed");
    }
}

class Program
{
    public static void Main()
    {
        // Create both object of producer and consumer
        Producer producer = new();
        Consumer consumer = new();

        // Create delegate objects of ThreadStart
        ThreadStart threadStart1 = producer.Produce;
        ThreadStart threadStart2 = consumer.Consume;

        // Create thread objects
        Thread producerThread = new(threadStart1)
        {
            Name = "Producer Thread",
        };
        Thread consumerThread = new(threadStart2)
        {
            Name = "Consumer Thread",
        };

        // Start threads
        producerThread.Start();
        consumerThread.Start();

        // Join both threads to main thread
        producerThread.Join();
        consumerThread.Join();

        Console.ReadKey();
    }
}